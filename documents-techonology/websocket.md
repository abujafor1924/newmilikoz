# üöÄ ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶™‡¶æ‡¶¨‡¶≤‡¶ø‡¶ï ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ - ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®

## üìã **‡¶è‡¶ï ‡¶®‡¶ú‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü**

| ‡¶¨‡¶ø‡¶≠‡¶æ‡¶ó | ‡¶¨‡¶ø‡¶¨‡¶∞‡¶£ |
|--------|----------|
| **‡¶™‡ßç‡¶∞‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§‡¶ø** | Django + Django Channels + WebSocket |
| **‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶ú** | SQLite (‡¶°‡¶ø‡¶´‡¶≤‡ßç‡¶ü) |
| **‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶§‡¶ø** | ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶™‡¶æ‡¶¨‡¶≤‡¶ø‡¶ï, ‡¶ï‡ßã‡¶®‡ßã ‡¶≤‡¶ó‡¶á‡¶® ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá ‡¶®‡¶æ |
| **‡¶´‡¶ø‡¶ö‡¶æ‡¶∞** | ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶≤-‡¶ü‡¶æ‡¶á‡¶Æ ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü, ‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø-‡¶∞‡ßÅ‡¶Æ, ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶™‡ßç‡¶∞‡ßã‡¶´‡¶æ‡¶á‡¶≤ |
| **API** | REST API + WebSocket |

---

## üìÅ **‡¶™‡ßç‡¶∞‡¶ï‡¶≤‡ßç‡¶™ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ - Step by Step**

### ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶ß‡¶æ‡¶™: ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™

```bash
# ‡ßß. ‡¶´‡ßã‡¶≤‡ßç‡¶°‡¶æ‡¶∞ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®
mkdir bangla-public-chat
cd bangla-public-chat

# ‡ß®. ‡¶≠‡¶æ‡¶∞‡ßç‡¶ö‡ßÅ‡¶Ø‡¶º‡¶æ‡¶≤ ‡¶è‡¶®‡¶≠‡¶æ‡¶Ø‡¶º‡¶∞‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®
python -m venv venv

# ‡ß©. ‡¶≠‡¶æ‡¶∞‡ßç‡¶ö‡ßÅ‡¶Ø‡¶º‡¶æ‡¶≤ ‡¶è‡¶®‡¶≠‡¶æ‡¶Ø‡¶º‡¶∞‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶ï‡ßç‡¶ü‡¶ø‡¶≠‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®
# Windows:
venv\Scripts\activate
# Mac/Linux:
source venv/bin/activate

# ‡ß™. pip ‡¶Ü‡¶™‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®
pip install --upgrade pip

# ‡ß´. ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ó‡¶†‡¶® ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®
bangla-public-chat/
‚îú‚îÄ‚îÄ manage.py
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ bangla_chat/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ settings.py
‚îÇ   ‚îú‚îÄ‚îÄ urls.py
‚îÇ   ‚îú‚îÄ‚îÄ asgi.py
‚îÇ   ‚îî‚îÄ‚îÄ wsgi.py
‚îú‚îÄ‚îÄ chat_app/
‚îÇ   ‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ admin.py
‚îÇ   ‚îú‚îÄ‚îÄ apps.py
‚îÇ   ‚îú‚îÄ‚îÄ models.py
‚îÇ   ‚îú‚îÄ‚îÄ serializers.py
‚îÇ   ‚îú‚îÄ‚îÄ views.py
‚îÇ   ‚îú‚îÄ‚îÄ urls.py
‚îÇ   ‚îú‚îÄ‚îÄ consumers.py
‚îÇ   ‚îî‚îÄ‚îÄ routing.py
‚îî‚îÄ‚îÄ README.md
```

### ‡¶¶‡ßç‡¶¨‡¶ø‡¶§‡ßÄ‡¶Ø‡¶º ‡¶ß‡¶æ‡¶™: ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ï‡¶®‡ßç‡¶ü‡ßá‡¶®‡ßç‡¶ü

---

## üìÑ **‡ßß. requirements.txt ‡¶´‡¶æ‡¶á‡¶≤**

```txt
# requirements.txt ‡¶´‡¶æ‡¶á‡¶≤‡¶ü‡¶ø ‡¶è‡¶á‡¶≠‡¶æ‡¶¨‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®

Django==4.2.7
channels==4.0.0
daphne==4.0.0
channels-redis==4.1.0
djangorestframework==3.14.0
django-cors-headers==4.2.0
pillow==10.1.0
python-decouple==3.8
```

**‡¶á‡¶®‡ßç‡¶∏‡¶ü‡¶≤‡ßá‡¶∂‡¶® ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶°:**
```bash
pip install -r requirements.txt
```

---

## ‚öôÔ∏è **‡ß®. ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶®**

### **bangla_chat/settings.py**

```python
"""
Django settings for bangla_chat project.
Generated by 'django-admin startproject'
"""

import os
from pathlib import Path
from decouple import config

# Build paths inside the project
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = config('SECRET_KEY', default='django-insecure-change-this-in-production')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = config('DEBUG', default=True, cast=bool)

ALLOWED_HOSTS = ['localhost', '127.0.0.1', '*']

# Application definition
INSTALLED_APPS = [
    'daphne',  # ‚úÖ Daphne must be first
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third party apps
    'channels',  # ‚úÖ Django Channels
    'rest_framework',
    'corsheaders',
    
    # Local apps
    'chat_app',  # ‚úÖ Our chat application
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'bangla_chat.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# WSGI & ASGI Configuration
WSGI_APPLICATION = 'bangla_chat.wsgi.application'
ASGI_APPLICATION = 'bangla_chat.asgi.application'  # ‚úÖ Important for Channels

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Password validation (Disabled for public chat)
AUTH_PASSWORD_VALIDATORS = []

# Internationalization
LANGUAGE_CODE = 'bn-bd'
TIME_ZONE = 'Asia/Dhaka'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Media files
MEDIA_URL = 'media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# REST Framework Configuration
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',  # ‚úÖ Public access
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 100,
}

# CORS Settings (Allow all for development)
CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

# ‚úÖ CHANNELS CONFIGURATION - MOST IMPORTANT
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels.layers.InMemoryChannelLayer',
    },
}

"""
For production with Redis, use this instead:
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [('127.0.0.1', 6379)],
        },
    },
}
"""
```

---

## üåê **‡ß©. ASGI ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶®**

### **bangla_chat/asgi.py**

```python
"""
ASGI config for bangla_chat project.
It exposes the ASGI callable as a module-level variable named `application`.
"""

import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
import chat_app.routing

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'bangla_chat.settings')

application = ProtocolTypeRouter({
    'http': get_asgi_application(),
    'websocket': AuthMiddlewareStack(
        URLRouter(
            chat_app.routing.websocket_urlpatterns
        )
    ),
})
```

---

## üîó **‡ß™. URL ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶®**

### **bangla_chat/urls.py**

```python
"""
URL configuration for bangla_chat project.
"""

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('chat_app.urls')),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

---

## üèóÔ∏è **‡ß´. ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ‡¶§‡ßà‡¶∞‡¶ø**

### **‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶°:**
```bash
python manage.py startapp chat_app
```

---

## üìä **‡ß¨. ‡¶Æ‡¶°‡ßá‡¶≤ ‡¶°‡¶ø‡¶´‡¶ø‡¶®‡ßá‡¶∂‡¶®**

### **chat_app/models.py**

```python
"""
Models for the chat application.
No authentication required - completely public chat.
"""

from django.db import models
from django.utils import timezone
import uuid

class ChatRoom(models.Model):
    """
    Chat room model - represents a chat room
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=100, verbose_name="‡¶∞‡ßÅ‡¶Æ‡ßá‡¶∞ ‡¶®‡¶æ‡¶Æ")
    description = models.TextField(blank=True, null=True, verbose_name="‡¶¨‡¶∞‡ßç‡¶£‡¶®‡¶æ")
    is_public = models.BooleanField(default=True, verbose_name="‡¶™‡¶æ‡¶¨‡¶≤‡¶ø‡¶ï ‡¶∞‡ßÅ‡¶Æ")
    max_users = models.IntegerField(default=100, verbose_name="‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="‡¶Ü‡¶™‡¶°‡ßá‡¶ü‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º")
    
    class Meta:
        verbose_name = "‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶∞‡ßÅ‡¶Æ"
        verbose_name_plural = "‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶∞‡ßÅ‡¶Æ‡¶∏‡¶Æ‡ßÇ‡¶π"
        ordering = ['-created_at']
    
    def __str__(self):
        return self.name
    
    @property
    def online_users_count(self):
        """Returns number of online users in this room"""
        return self.active_connections.count()
    
    @property
    def total_messages_count(self):
        """Returns total messages in this room"""
        return self.messages.count()

class ChatUser(models.Model):
    """
    Chat user model - temporary users for chat sessions
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    session_id = models.CharField(max_length=255, unique=True, verbose_name="‡¶∏‡ßá‡¶∂‡¶® ‡¶Ü‡¶á‡¶°‡¶ø")
    username = models.CharField(max_length=100, verbose_name="‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶®‡¶æ‡¶Æ")
    color = models.CharField(max_length=7, default='#007bff', verbose_name="‡¶∞‡¶Ç")  # Hex color
    is_online = models.BooleanField(default=False, verbose_name="‡¶Ö‡¶®‡¶≤‡¶æ‡¶á‡¶®")
    current_room = models.ForeignKey(
        ChatRoom, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='current_users',
        verbose_name="‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶∞‡ßÅ‡¶Æ"
    )
    last_seen = models.DateTimeField(default=timezone.now, verbose_name="‡¶∂‡ßá‡¶∑ ‡¶¶‡ßá‡¶ñ‡¶æ")
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="‡¶§‡ßà‡¶∞‡¶ø‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º")
    
    class Meta:
        verbose_name = "‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ"
        verbose_name_plural = "‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶ó‡¶£"
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.username} ({self.session_id[:8]}...)"

class Message(models.Model):
    """
    Message model - stores chat messages
    """
    MESSAGE_TYPES = [
        ('text', '‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü'),
        ('image', '‡¶õ‡¶¨‡¶ø'),
        ('file', '‡¶´‡¶æ‡¶á‡¶≤'),
        ('system', '‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    room = models.ForeignKey(
        ChatRoom, 
        on_delete=models.CASCADE, 
        related_name='messages',
        verbose_name="‡¶∞‡ßÅ‡¶Æ"
    )
    user = models.ForeignKey(
        ChatUser, 
        on_delete=models.CASCADE, 
        related_name='messages',
        verbose_name="‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ"
    )
    content = models.TextField(verbose_name="‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ")
    message_type = models.CharField(
        max_length=20, 
        choices=MESSAGE_TYPES, 
        default='text',
        verbose_name="‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ‡¶∞ ‡¶ß‡¶∞‡¶®"
    )
    file_url = models.URLField(blank=True, null=True, verbose_name="‡¶´‡¶æ‡¶á‡¶≤ ‡¶≤‡¶ø‡¶Ç‡¶ï")
    timestamp = models.DateTimeField(auto_now_add=True, verbose_name="‡¶∏‡¶Æ‡¶Ø‡¶º")
    
    class Meta:
        verbose_name = "‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ"
        verbose_name_plural = "‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ‡¶∏‡¶Æ‡ßÇ‡¶π"
        ordering = ['timestamp']
    
    def __str__(self):
        return f"{self.user.username}: {self.content[:50]}"

class ActiveConnection(models.Model):
    """
    Tracks active WebSocket connections
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    user = models.ForeignKey(
        ChatUser, 
        on_delete=models.CASCADE, 
        related_name='active_connections',
        verbose_name="‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ"
    )
    channel_name = models.CharField(max_length=255, verbose_name="‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤ ‡¶®‡¶æ‡¶Æ")
    room = models.ForeignKey(
        ChatRoom, 
        on_delete=models.CASCADE, 
        related_name='active_connections',
        verbose_name="‡¶∞‡ßÅ‡¶Æ"
    )
    connected_at = models.DateTimeField(auto_now_add=True, verbose_name="‡¶∏‡¶Ç‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§‡¶ø‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º")
    
    class Meta:
        verbose_name = "‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó"
        verbose_name_plural = "‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó‡¶∏‡¶Æ‡ßÇ‡¶π"
        ordering = ['-connected_at']
    
    def __str__(self):
        return f"{self.user.username} - {self.room.name}"
```

---

## üîÑ **‡ß≠. ‡¶Æ‡¶æ‡¶á‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶§‡ßà‡¶∞‡¶ø ‡¶ì ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶æ‡¶á**

```bash
# ‡¶Æ‡¶æ‡¶á‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶§‡ßà‡¶∞‡¶ø
python manage.py makemigrations chat_app

# ‡¶Æ‡¶æ‡¶á‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶ö‡ßá‡¶ï
python manage.py sqlmigrate chat_app 0001

# ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶ú‡ßá ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶æ‡¶á
python manage.py migrate
```

**‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü:**
```
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions, chat_app
Running migrations:
  Applying chat_app.0001_initial... OK
```

---

## üì¶ **‡ßÆ. ‡¶∏‡¶ø‡¶∞‡¶ø‡¶Ø‡¶º‡¶æ‡¶≤‡¶æ‡¶á‡¶ú‡¶æ‡¶∞**

### **chat_app/serializers.py**

```python
"""
Serializers for the chat API.
"""

from rest_framework import serializers
from .models import ChatRoom, ChatUser, Message, ActiveConnection

class ChatRoomSerializer(serializers.ModelSerializer):
    online_users_count = serializers.IntegerField(read_only=True)
    total_messages_count = serializers.IntegerField(read_only=True)
    
    class Meta:
        model = ChatRoom
        fields = [
            'id', 'name', 'description', 'is_public', 'max_users',
            'online_users_count', 'total_messages_count', 'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'created_at', 'updated_at']

class ChatUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = ChatUser
        fields = ['id', 'username', 'color', 'is_online', 'last_seen', 'created_at']
        read_only_fields = ['id', 'is_online', 'last_seen', 'created_at']

class MessageSerializer(serializers.ModelSerializer):
    user = ChatUserSerializer(read_only=True)
    room_id = serializers.UUIDField(write_only=True)
    
    class Meta:
        model = Message
        fields = [
            'id', 'room_id', 'user', 'content', 'message_type', 
            'file_url', 'timestamp'
        ]
        read_only_fields = ['id', 'user', 'timestamp']

class ActiveConnectionSerializer(serializers.ModelSerializer):
    user = ChatUserSerializer(read_only=True)
    room = ChatRoomSerializer(read_only=True)
    
    class Meta:
        model = ActiveConnection
        fields = ['id', 'user', 'room', 'channel_name', 'connected_at']

# Request/Response serializers
class CreateUserRequestSerializer(serializers.Serializer):
    username = serializers.CharField(max_length=100)
    color = serializers.CharField(max_length=7, required=False, default='#007bff')

class CreateUserResponseSerializer(serializers.Serializer):
    user_id = serializers.UUIDField()
    session_id = serializers.CharField()
    username = serializers.CharField()
    color = serializers.CharField()
    message = serializers.CharField()

class JoinRoomRequestSerializer(serializers.Serializer):
    room_id = serializers.UUIDField()
    username = serializers.CharField(max_length=100)
    color = serializers.CharField(max_length=7, required=False, default='#007bff')

class JoinRoomResponseSerializer(serializers.Serializer):
    room_id = serializers.UUIDField()
    room_name = serializers.CharField()
    user_id = serializers.UUIDField()
    session_id = serializers.CharField()
    username = serializers.CharField()
    color = serializers.CharField()
    websocket_url = serializers.CharField()
```

---

## üéØ **‡ßØ. ‡¶≠‡¶ø‡¶â‡¶∏ (API ‡¶è‡¶®‡ßç‡¶°‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü)**

### **chat_app/views.py**

```python
"""
API views for the chat application.
"""

from rest_framework import viewsets, status, generics
from rest_framework.decorators import action, api_view
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.db.models import Count, Q
from django.utils import timezone
import uuid

from .models import ChatRoom, ChatUser, Message, ActiveConnection
from .serializers import (
    ChatRoomSerializer, ChatUserSerializer, MessageSerializer,
    CreateUserRequestSerializer, JoinRoomRequestSerializer,
    CreateUserResponseSerializer, JoinRoomResponseSerializer
)

# ==================== CHAT ROOM VIEWS ====================
class ChatRoomViewSet(viewsets.ModelViewSet):
    """
    API endpoint for chat rooms
    """
    queryset = ChatRoom.objects.filter(is_public=True)
    serializer_class = ChatRoomSerializer
    
    @action(detail=True, methods=['GET'])
    def messages(self, request, pk=None):
        """Get messages for a specific room"""
        room = self.get_object()
        messages = Message.objects.filter(room=room).order_by('-timestamp')[:100]
        serializer = MessageSerializer(messages, many=True)
        return Response({
            'room_id': str(room.id),
            'room_name': room.name,
            'messages': serializer.data,
            'total_messages': messages.count()
        })
    
    @action(detail=True, methods=['GET'])
    def users(self, request, pk=None):
        """Get online users in a room"""
        room = self.get_object()
        active_connections = ActiveConnection.objects.filter(room=room).select_related('user')
        users = [conn.user for conn in active_connections]
        serializer = ChatUserSerializer(users, many=True)
        return Response({
            'room_id': str(room.id),
            'online_users': serializer.data,
            'total_online': len(users)
        })
    
    @action(detail=False, methods=['GET'])
    def popular(self, request):
        """Get popular rooms (most users)"""
        rooms = ChatRoom.objects.annotate(
            user_count=Count('active_connections')
        ).filter(is_public=True).order_by('-user_count')[:10]
        serializer = self.get_serializer(rooms, many=True)
        return Response({
            'status': 'success',
            'count': rooms.count(),
            'rooms': serializer.data
        })

# ==================== MESSAGE VIEWS ====================
class MessageViewSet(viewsets.ModelViewSet):
    """
    API endpoint for messages
    """
    queryset = Message.objects.all()
    serializer_class = MessageSerializer
    
    def get_queryset(self):
        queryset = super().get_queryset()
        room_id = self.request.query_params.get('room_id')
        if room_id:
            queryset = queryset.filter(room_id=room_id)
        return queryset.order_by('-timestamp')[:100]

# ==================== USER MANAGEMENT ====================
class CreateUserView(APIView):
    """
    Create a new chat user
    """
    def post(self, request):
        serializer = CreateUserRequestSerializer(data=request.data)
        if serializer.is_valid():
            # Generate unique session ID
            session_id = str(uuid.uuid4())
            
            # Create user
            user = ChatUser.objects.create(
                session_id=session_id,
                username=serializer.validated_data['username'],
                color=serializer.validated_data.get('color', '#007bff'),
                is_online=True,
                last_seen=timezone.now()
            )
            
            response_data = {
                'user_id': str(user.id),
                'session_id': session_id,
                'username': user.username,
                'color': user.color,
                'message': '‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá'
            }
            
            return Response(response_data, status=status.HTTP_201_CREATED)
        
        return Response({
            'status': 'error',
            'errors': serializer.errors
        }, status=status.HTTP_400_BAD_REQUEST)

class JoinRoomView(APIView):
    """
    Join a chat room
    """
    def post(self, request):
        serializer = JoinRoomRequestSerializer(data=request.data)
        if serializer.is_valid():
            room_id = serializer.validated_data['room_id']
            username = serializer.validated_data['username']
            color = serializer.validated_data.get('color', '#007bff')
            
            # Get or create room
            try:
                room = ChatRoom.objects.get(id=room_id)
            except ChatRoom.DoesNotExist:
                # Create new room if doesn't exist
                room = ChatRoom.objects.create(
                    id=room_id,
                    name=f"‡¶∞‡ßÅ‡¶Æ {str(room_id)[:8]}",
                    is_public=True
                )
            
            # Generate session ID
            session_id = str(uuid.uuid4())
            
            # Create user
            user = ChatUser.objects.create(
                session_id=session_id,
                username=username,
                color=color,
                is_online=True,
                current_room=room,
                last_seen=timezone.now()
            )
            
            # Build WebSocket URL
            base_url = request.build_absolute_uri('/').rstrip('/')
            ws_url = f"ws://{request.get_host()}/ws/chat/{room.id}/"
            ws_url += f"?username={username}&color={color}&session_id={session_id}"
            
            response_data = {
                'room_id': str(room.id),
                'room_name': room.name,
                'user_id': str(user.id),
                'session_id': session_id,
                'username': user.username,
                'color': user.color,
                'websocket_url': ws_url,
                'message': '‡¶∞‡ßÅ‡¶Æ‡ßá ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ø‡ßã‡¶ó‡¶¶‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá'
            }
            
            return Response(response_data, status=status.HTTP_200_OK)
        
        return Response({
            'status': 'error',
            'errors': serializer.errors
        }, status=status.HTTP_400_BAD_REQUEST)

# ==================== PUBLIC ENDPOINTS ====================
class PublicRoomsView(APIView):
    """
    Get all public rooms
    """
    def get(self, request):
        rooms = ChatRoom.objects.filter(is_public=True).annotate(
            online_count=Count('active_connections'),
            message_count=Count('messages')
        ).order_by('-online_count')
        
        data = []
        for room in rooms:
            data.append({
                'id': str(room.id),
                'name': room.name,
                'description': room.description,
                'online_users': room.online_count,
                'total_messages': room.message_count,
                'max_users': room.max_users,
                'created_at': room.created_at,
                'updated_at': room.updated_at
            })
        
        return Response({
            'status': 'success',
            'count': len(data),
            'rooms': data
        })

class RoomStatsView(APIView):
    """
    Get statistics for a specific room
    """
    def get(self, request, room_id):
        try:
            room = ChatRoom.objects.get(id=room_id)
            
            online_users = ActiveConnection.objects.filter(room=room).count()
            total_messages = Message.objects.filter(room=room).count()
            
            # Get recent messages
            recent_messages = Message.objects.filter(room=room).order_by('-timestamp')[:5]
            recent_messages_data = MessageSerializer(recent_messages, many=True).data
            
            return Response({
                'room_id': str(room.id),
                'room_name': room.name,
                'online_users': online_users,
                'total_messages': total_messages,
                'max_users': room.max_users,
                'is_public': room.is_public,
                'created_at': room.created_at,
                'updated_at': room.updated_at,
                'recent_messages': recent_messages_data
            })
            
        except ChatRoom.DoesNotExist:
            return Response({
                'status': 'error',
                'message': '‡¶∞‡ßÅ‡¶Æ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø'
            }, status=status.HTTP_404_NOT_FOUND)

@api_view(['GET'])
def system_status(request):
    """
    Get system status and statistics
    """
    total_rooms = ChatRoom.objects.count()
    total_users = ChatUser.objects.count()
    total_messages = Message.objects.count()
    
    # Count distinct online users
    online_users = ActiveConnection.objects.values('user').distinct().count()
    active_rooms = ActiveConnection.objects.values('room').distinct().count()
    
    return Response({
        'status': '‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º',
        'server_time': timezone.now().isoformat(),
        'statistics': {
            'total_rooms': total_rooms,
            'total_users': total_users,
            'total_messages': total_messages,
            'online_users': online_users,
            'active_rooms': active_rooms
        },
        'system_info': {
            'project': '‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶™‡¶æ‡¶¨‡¶≤‡¶ø‡¶ï ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü',
            'version': '1.0.0',
            'description': '‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶™‡¶æ‡¶¨‡¶≤‡¶ø‡¶ï ‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶≤-‡¶ü‡¶æ‡¶á‡¶Æ ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶®'
        }
    })
```

---

## ‚ö° **‡ßß‡ß¶. WebSocket ‡¶ï‡¶®‡¶ú‡¶ø‡¶â‡¶Æ‡¶æ‡¶∞**

### **chat_app/consumers.py**

```python
"""
WebSocket consumer for real-time chat.
"""

import json
import uuid
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.utils import timezone

from .models import ChatRoom, ChatUser, Message, ActiveConnection

class ChatConsumer(AsyncWebsocketConsumer):
    """
    WebSocket consumer for handling chat connections
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.room_id = None
        self.room_group_name = None
        self.user = None
        self.user_id = None
        self.session_id = None

    async def connect(self):
        """
        Handle WebSocket connection
        """
        try:
            # Get room_id from URL route
            self.room_id = self.scope['url_route']['kwargs']['room_id']
            self.room_group_name = f'chat_{self.room_id}'
            
            # Parse query parameters
            query_string = self.scope.get('query_string', b'').decode()
            params = {}
            if query_string:
                for param in query_string.split('&'):
                    if '=' in param:
                        key, value = param.split('=', 1)
                        params[key] = value
            
            username = params.get('username', '‡¶Ö‡¶§‡¶ø‡¶•‡¶ø')
            color = params.get('color', '#007bff')
            self.session_id = params.get('session_id', str(uuid.uuid4()))
            
            # Create or get user
            self.user = await self.get_or_create_user(username, color, self.session_id)
            self.user_id = str(self.user.id)
            
            # Get or create room
            room = await self.get_or_create_room()
            
            # Check if room is full
            online_count = await self.get_online_users_count()
            if online_count >= room.max_users:
                await self.close(code=4001)  # Room full
                return
            
            # Join room group
            await self.channel_layer.group_add(
                self.room_group_name,
                self.channel_name
            )
            
            # Accept connection
            await self.accept()
            
            # Update user status
            await self.update_user_status(True, room)
            
            # Save connection
            await self.save_connection(room)
            
            # Send welcome message
            welcome_message = f"üéâ {username} ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü‡¶∞‡ßÅ‡¶Æ‡ßá ‡¶Ø‡ßã‡¶ó ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶®!"
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'system_message',
                    'message': welcome_message,
                    'user_id': self.user_id,
                    'username': username,
                    'timestamp': timezone.now().isoformat(),
                }
            )
            
            # Send updated user list to everyone
            await self.send_user_list()
            
        except Exception as e:
            print(f"‚ùå Connection error: {e}")
            await self.close()

    async def disconnect(self, close_code):
        """
        Handle WebSocket disconnection
        """
        if self.room_group_name and self.user:
            try:
                # Leave room group
                await self.channel_layer.group_discard(
                    self.room_group_name,
                    self.channel_name
                )
                
                # Update user status
                await self.update_user_status(False, None)
                
                # Remove connection
                await self.remove_connection()
                
                # Send leave message (if not room full)
                if close_code != 4001:
                    leave_message = f"üëã {self.user.username} ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü‡¶∞‡ßÅ‡¶Æ ‡¶õ‡ßá‡¶°‡¶º‡ßá‡¶õ‡ßá‡¶®"
                    await self.channel_layer.group_send(
                        self.room_group_name,
                        {
                            'type': 'system_message',
                            'message': leave_message,
                            'user_id': self.user_id,
                            'username': self.user.username,
                            'timestamp': timezone.now().isoformat(),
                        }
                    )
                    
                    # Update user list
                    await self.send_user_list()
                    
            except Exception as e:
                print(f"‚ùå Disconnection error: {e}")

    async def receive(self, text_data):
        """
        Handle incoming WebSocket messages
        """
        try:
            data = json.loads(text_data)
            message_type = data.get('type', 'message')
            
            if message_type == 'message':
                await self.handle_message(data)
                
            elif message_type == 'typing':
                await self.handle_typing(data)
                
            elif message_type == 'user_update':
                await self.handle_user_update(data)
                
        except json.JSONDecodeError:
            await self.send_error("‡¶Ö‡¶¨‡ßà‡¶ß JSON ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü")
        except Exception as e:
            await self.send_error(f"‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶è‡¶∞‡¶∞: {str(e)}")

    # ==================== MESSAGE HANDLERS ====================
    
    async def handle_message(self, data):
        """Handle chat messages"""
        content = data.get('content', '').strip()
        if content:
            # Save message to database
            message_id = await self.save_message(content)
            
            if message_id:
                # Broadcast message to room
                await self.channel_layer.group_send(
                    self.room_group_name,
                    {
                        'type': 'chat_message',
                        'message': content,
                        'user_id': self.user_id,
                        'username': self.user.username,
                        'user_color': self.user.color,
                        'message_id': str(message_id),
                        'timestamp': timezone.now().isoformat(),
                    }
                )

    async def handle_typing(self, data):
        """Handle typing indicators"""
        is_typing = data.get('typing', False)
        
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'typing_indicator',
                'user_id': self.user_id,
                'username': self.user.username,
                'typing': is_typing,
                'timestamp': timezone.now().isoformat(),
            }
        )

    async def handle_user_update(self, data):
        """Handle user profile updates"""
        new_username = data.get('username', '').strip()
        new_color = data.get('color', self.user.color)
        
        if new_username and new_username != self.user.username:
            old_username = self.user.username
            await self.update_user_info(new_username, new_color)
            
            # Notify everyone about username change
            notification = f"üìù {old_username} ‡¶è‡¶ñ‡¶® {new_username} ‡¶®‡¶æ‡¶Æ‡ßá ‡¶™‡¶∞‡¶ø‡¶ö‡¶ø‡¶§"
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'system_message',
                    'message': notification,
                    'user_id': self.user_id,
                    'username': new_username,
                    'timestamp': timezone.now().isoformat(),
                }
            )
            
            # Update user list
            await self.send_user_list()

    # ==================== WEBSOCKET EVENT HANDLERS ====================
    
    async def chat_message(self, event):
        """Send chat message to client"""
        await self.send(text_data=json.dumps({
            'type': 'message',
            'message': event['message'],
            'user_id': event['user_id'],
            'username': event['username'],
            'user_color': event['user_color'],
            'message_id': event['message_id'],
            'timestamp': event['timestamp'],
        }))

    async def system_message(self, event):
        """Send system message to client"""
        await self.send(text_data=json.dumps({
            'type': 'system',
            'message': event['message'],
            'user_id': event['user_id'],
            'username': event['username'],
            'timestamp': event['timestamp'],
        }))

    async def typing_indicator(self, event):
        """Send typing indicator to client"""
        await self.send(text_data=json.dumps({
            'type': 'typing',
            'user_id': event['user_id'],
            'username': event['username'],
            'typing': event['typing'],
            'timestamp': event['timestamp'],
        }))

    async def user_list_update(self, event):
        """Send updated user list to client"""
        await self.send(text_data=json.dumps({
            'type': 'user_list',
            'users': event['users'],
            'timestamp': event['timestamp'],
        }))

    # ==================== DATABASE OPERATIONS ====================
    
    @database_sync_to_async
    def get_or_create_user(self, username, color, session_id):
        """Get or create a chat user"""
        try:
            user = ChatUser.objects.get(session_id=session_id)
            user.username = username
            user.color = color
            user.is_online = True
            user.save()
        except ChatUser.DoesNotExist:
            user = ChatUser.objects.create(
                session_id=session_id,
                username=username,
                color=color,
                is_online=True
            )
        return user

    @database_sync_to_async
    def get_or_create_room(self):
        """Get or create a chat room"""
        try:
            room = ChatRoom.objects.get(id=self.room_id)
        except ChatRoom.DoesNotExist:
            room = ChatRoom.objects.create(
                id=self.room_id,
                name=f"‡¶∞‡ßÅ‡¶Æ {str(self.room_id)[:8]}",
                is_public=True
            )
        return room

    @database_sync_to_async
    def get_online_users_count(self):
        """Count online users in room"""
        return ActiveConnection.objects.filter(room_id=self.room_id).count()

    @database_sync_to_async
    def update_user_status(self, is_online, room):
        """Update user online status"""
        self.user.is_online = is_online
        self.user.current_room = room
        self.user.last_seen = timezone.now()
        self.user.save()

    @database_sync_to_async
    def save_connection(self, room):
        """Save active connection"""
        ActiveConnection.objects.create(
            user=self.user,
            channel_name=self.channel_name,
            room=room
        )

    @database_sync_to_async
    def remove_connection(self):
        """Remove active connection"""
        ActiveConnection.objects.filter(
            user=self.user,
            channel_name=self.channel_name
        ).delete()

    @database_sync_to_async
    def save_message(self, content):
        """Save message to database"""
        try:
            room = ChatRoom.objects.get(id=self.room_id)
            message = Message.objects.create(
                room=room,
                user=self.user,
                content=content,
                message_type='text'
            )
            return message.id
        except ChatRoom.DoesNotExist:
            return None

    @database_sync_to_async
    def update_user_info(self, new_username, new_color):
        """Update user information"""
        self.user.username = new_username
        self.user.color = new_color
        self.user.save()

    @database_sync_to_async
    def get_online_users(self):
        """Get list of online users in room"""
        connections = ActiveConnection.objects.filter(
            room_id=self.room_id
        ).select_related('user')
        
        users = []
        for conn in connections:
            users.append({
                'id': str(conn.user.id),
                'username': conn.user.username,
                'color': conn.user.color,
                'joined_at': conn.connected_at.isoformat(),
                'is_online': True
            })
        return users

    async def send_user_list(self):
        """Send updated user list to all clients"""
        users = await self.get_online_users()
        
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'user_list_update',
                'users': users,
                'timestamp': timezone.now().isoformat(),
            }
        )

    async def send_error(self, error_message):
        """Send error message to client"""
        await self.send(text_data=json.dumps({
            'type': 'error',
            'message': error_message,
            'timestamp': timezone.now().isoformat(),
        }))
```

---

## üõ£Ô∏è **‡ßß‡ßß. ‡¶∞‡¶æ‡¶â‡¶ü‡¶ø‡¶Ç**

### **chat_app/routing.py**

```python
"""
WebSocket routing for the chat application.
"""

from django.urls import path
from . import consumers

websocket_urlpatterns = [
    path('ws/chat/<uuid:room_id>/', consumers.ChatConsumer.as_asgi()),
]
```

### **chat_app/urls.py**

```python
"""
URL configuration for chat_app.
"""

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views

# Create router
router = DefaultRouter()
router.register(r'rooms', views.ChatRoomViewSet, basename='rooms')
router.register(r'messages', views.MessageViewSet, basename='messages')

# URL patterns
urlpatterns = [
    # API Routes
    path('', include(router.urls)),
    
    # User Management
    path('create-user/', views.CreateUserView.as_view(), name='create_user'),
    path('join-room/', views.JoinRoomView.as_view(), name='join_room'),
    
    # Public Rooms
    path('public-rooms/', views.PublicRoomsView.as_view(), name='public_rooms'),
    path('rooms/<uuid:room_id>/stats/', views.RoomStatsView.as_view(), name='room_stats'),
    
    # System Status
    path('status/', views.system_status, name='system_status'),
    
    # Health Check
    path('health/', views.system_status, name='health_check'),
]
```

---

## üëë **‡ßß‡ß®. ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶®**

### **chat_app/admin.py**

```python
"""
Admin configuration for chat_app.
"""

from django.contrib import admin
from .models import ChatRoom, ChatUser, Message, ActiveConnection

@admin.register(ChatRoom)
class ChatRoomAdmin(admin.ModelAdmin):
    list_display = ['name', 'is_public', 'max_users', 'created_at', 'online_users_count_display']
    list_filter = ['is_public', 'created_at']
    search_fields = ['name', 'description']
    readonly_fields = ['created_at', 'updated_at']
    
    fieldsets = (
        ('‡¶Æ‡ßÇ‡¶≤ ‡¶§‡¶•‡ßç‡¶Ø', {
            'fields': ('name', 'description', 'is_public', 'max_users')
        }),
        ('‡¶∏‡¶Æ‡¶Ø‡¶º', {
            'fields': ('created_at', 'updated_at')
        }),
    )
    
    def online_users_count_display(self, obj):
        return obj.online_users_count
    online_users_count_display.short_description = '‡¶Ö‡¶®‡¶≤‡¶æ‡¶á‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ'
    online_users_count_display.admin_order_field = 'active_connections__count'

@admin.register(ChatUser)
class ChatUserAdmin(admin.ModelAdmin):
    list_display = ['username', 'session_id_short', 'is_online', 'current_room', 'last_seen']
    list_filter = ['is_online', 'created_at']
    search_fields = ['username', 'session_id']
    readonly_fields = ['session_id', 'created_at', 'last_seen']
    
    def session_id_short(self, obj):
        return obj.session_id[:20] + '...' if len(obj.session_id) > 20 else obj.session_id
    session_id_short.short_description = '‡¶∏‡ßá‡¶∂‡¶® ‡¶Ü‡¶á‡¶°‡¶ø'

@admin.register(Message)
class MessageAdmin(admin.ModelAdmin):
    list_display = ['user', 'room', 'content_short', 'message_type', 'timestamp']
    list_filter = ['message_type', 'timestamp', 'room']
    search_fields = ['content', 'user__username']
    readonly_fields = ['timestamp']
    date_hierarchy = 'timestamp'
    
    def content_short(self, obj):
        return obj.content[:50] + '...' if len(obj.content) > 50 else obj.content
    content_short.short_description = '‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ'

@admin.register(ActiveConnection)
class ActiveConnectionAdmin(admin.ModelAdmin):
    list_display = ['user', 'room', 'channel_name_short', 'connected_at']
    list_filter = ['connected_at', 'room']
    search_fields = ['user__username', 'channel_name']
    readonly_fields = ['connected_at']
    
    def channel_name_short(self, obj):
        return obj.channel_name[:30] + '...' if len(obj.channel_name) > 30 else obj.channel_name
    channel_name_short.short_description = '‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤'
```

---

## üéÆ **‡ßß‡ß©. ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶®**

### **chat_app/apps.py**

```python
from django.apps import AppConfig

class ChatAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'chat_app'
    verbose_name = '‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶®'
```

### **__init__.py ‡¶´‡¶æ‡¶á‡¶≤‡¶∏**

**bangla_chat/__init__.py**
```python
# Empty file - indicates this is a Python package
```

**chat_app/__init__.py**
```python
# Empty file - indicates this is a Python package
```

---

## üöÄ **‡ßß‡ß™. ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶∞‡¶æ‡¶®**

### **‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡¶¨‡¶æ‡¶∞ ‡¶∞‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ó‡¶æ‡¶á‡¶°:**

```bash
# ‡¶ß‡¶æ‡¶™ ‡ßß: ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü ‡¶´‡ßã‡¶≤‡ßç‡¶°‡¶æ‡¶∞‡ßá ‡¶Ø‡¶æ‡¶®
cd bangla-public-chat

# ‡¶ß‡¶æ‡¶™ ‡ß®: ‡¶≠‡¶æ‡¶∞‡ßç‡¶ö‡ßÅ‡¶Ø‡¶º‡¶æ‡¶≤ ‡¶è‡¶®‡¶≠‡¶æ‡¶Ø‡¶º‡¶∞‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶è‡¶ï‡ßç‡¶ü‡¶ø‡¶≠‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®
# Windows:
venv\Scripts\activate
# Mac/Linux:
source venv/bin/activate

# ‡¶ß‡¶æ‡¶™ ‡ß©: ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡ßÄ‡¶Ø‡¶º ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ú ‡¶á‡¶®‡ßç‡¶∏‡¶ü‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®
pip install -r requirements.txt

# ‡¶ß‡¶æ‡¶™ ‡ß™: ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶ú ‡¶Æ‡¶æ‡¶á‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®
python manage.py makemigrations
python manage.py migrate

# ‡¶ß‡¶æ‡¶™ ‡ß´: ‡¶°‡ßá‡¶Æ‡ßã ‡¶°‡¶æ‡¶ü‡¶æ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶® (‡¶ê‡¶ö‡ßç‡¶õ‡¶ø‡¶ï)
python manage.py shell -c "
from chat_app.models import ChatRoom
from uuid import uuid4
import datetime

rooms_data = [
    {
        'id': uuid4(),
        'name': '‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ',
        'description': '‡¶∏‡¶¨ ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶Æ‡ßÅ‡¶ï‡ßç‡¶§ ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ',
        'is_public': True,
        'max_users': 200
    },
    {
        'id': uuid4(),
        'name': '‡¶ü‡ßá‡¶ï‡¶®‡ßã‡¶≤‡¶ú‡¶ø',
        'description': '‡¶ü‡ßá‡¶ï‡¶®‡ßã‡¶≤‡¶ú‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ø‡¶Ç ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ',
        'is_public': True,
        'max_users': 150
    },
    {
        'id': uuid4(),
        'name': '‡¶ñ‡ßá‡¶≤‡¶æ‡¶ß‡ßÅ‡¶≤‡¶æ',
        'description': '‡¶ï‡ßç‡¶∞‡¶ø‡¶ï‡ßá‡¶ü, ‡¶´‡ßÅ‡¶ü‡¶¨‡¶≤ ‡¶∏‡¶π ‡¶∏‡¶¨ ‡¶ñ‡ßá‡¶≤‡¶æ‡¶ß‡ßÅ‡¶≤‡¶æ',
        'is_public': True,
        'max_users': 150
    },
    {
        'id': uuid4(),
        'name': '‡¶∏‡¶ø‡¶®‡ßá‡¶Æ‡¶æ-‡¶ó‡¶æ‡¶®',
        'description': '‡¶∏‡¶ø‡¶®‡ßá‡¶Æ‡¶æ, ‡¶ó‡¶æ‡¶® ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶ø‡¶®‡ßã‡¶¶‡¶®',
        'is_public': True,
        'max_users': 150
    },
]

for room_info in rooms_data:
    ChatRoom.objects.create(**room_info)

print('‚úÖ ‡ß™‡¶ü‡¶ø ‡¶°‡ßá‡¶Æ‡ßã ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶∞‡ßÅ‡¶Æ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá')
"

# ‡¶ß‡¶æ‡¶™ ‡ß¨: ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®
python manage.py createsuperuser
# ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡¶®‡ßá‡¶Æ: admin
# ‡¶á‡¶Æ‡ßá‡¶á‡¶≤: admin@example.com
# ‡¶™‡¶æ‡¶∏‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶°: admin123

# ‡¶ß‡¶æ‡¶™ ‡ß≠: ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®
python manage.py runserver

# ‡¶ß‡¶æ‡¶™ ‡ßÆ: ‡¶¨‡ßç‡¶∞‡¶æ‡¶â‡¶ú‡¶æ‡¶∞‡ßá ‡¶Ø‡¶æ‡¶®
# http://localhost:8000/api/public-rooms/
```

---

## üì° **‡ßß‡ß´. API ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®**

### **BASE URL:** `http://localhost:8000/api/`

### **‡ßß. ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏**
```http
GET /api/status/
```
**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
```json
{
    "status": "‡¶∏‡¶ï‡ßç‡¶∞‡¶ø‡¶Ø‡¶º",
    "server_time": "2024-01-15T10:30:00+06:00",
    "statistics": {
        "total_rooms": 4,
        "total_users": 150,
        "total_messages": 1250,
        "online_users": 25,
        "active_rooms": 3
    }
}
```

### **‡ß®. ‡¶™‡¶æ‡¶¨‡¶≤‡¶ø‡¶ï ‡¶∞‡ßÅ‡¶Æ ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü**
```http
GET /api/public-rooms/
```
**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
```json
{
    "status": "success",
    "count": 4,
    "rooms": [
        {
            "id": "123e4567-e89b-12d3-a456-426614174000",
            "name": "‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ",
            "description": "‡¶∏‡¶¨ ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶Æ‡ßÅ‡¶ï‡ßç‡¶§ ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ",
            "online_users": 15,
            "total_messages": 500,
            "max_users": 200,
            "created_at": "2024-01-15T10:00:00+06:00"
        }
    ]
}
```

### **‡ß©. ‡¶®‡¶§‡ßÅ‡¶® ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶§‡ßà‡¶∞‡¶ø**
```http
POST /api/create-user/
Content-Type: application/json

{
    "username": "‡¶∞‡¶æ‡¶ï‡¶ø‡¶¨",
    "color": "#ff0000"
}
```
**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
```json
{
    "user_id": "123e4567-e89b-12d3-a456-426614174001",
    "session_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
    "username": "‡¶∞‡¶æ‡¶ï‡¶ø‡¶¨",
    "color": "#ff0000",
    "message": "‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá"
}
```

### **‡ß™. ‡¶∞‡ßÅ‡¶Æ‡ßá ‡¶ú‡¶Ø‡¶º‡ßá‡¶®**
```http
POST /api/join-room/
Content-Type: application/json

{
    "room_id": "123e4567-e89b-12d3-a456-426614174000",
    "username": "‡¶∞‡¶æ‡¶ï‡¶ø‡¶¨",
    "color": "#ff0000"
}
```
**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
```json
{
    "room_id": "123e4567-e89b-12d3-a456-426614174000",
    "room_name": "‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ",
    "user_id": "123e4567-e89b-12d3-a456-426614174001",
    "session_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
    "username": "‡¶∞‡¶æ‡¶ï‡¶ø‡¶¨",
    "color": "#ff0000",
    "websocket_url": "ws://localhost:8000/ws/chat/123e4567-e89b-12d3-a456-426614174000/?username=‡¶∞‡¶æ‡¶ï‡¶ø‡¶¨&color=%23ff0000&session_id=a1b2c3d4-e5f6-7890-1234-567890abcdef",
    "message": "‡¶∞‡ßÅ‡¶Æ‡ßá ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ø‡ßã‡¶ó‡¶¶‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá"
}
```

### **‡ß´. ‡¶∞‡ßÅ‡¶Æ‡ßá‡¶∞ ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®**
```http
GET /api/rooms/{room_id}/messages/
```
**‡¶â‡¶§‡ßç‡¶§‡¶∞:**
```json
{
    "room_id": "123e4567-e89b-12d3-a456-426614174000",
    "room_name": "‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ",
    "messages": [
        {
            "id": "223e4567-e89b-12d3-a456-426614174002",
            "user": {
                "id": "123e4567-e89b-12d3-a456-426614174001",
                "username": "‡¶∞‡¶æ‡¶ï‡¶ø‡¶¨",
                "color": "#ff0000",
                "is_online": true,
                "last_seen": "2024-01-15T10:25:00+06:00"
            },
            "content": "‡¶π‡ßç‡¶Ø‡¶æ‡¶≤‡ßã ‡¶∏‡¶¨‡¶æ‡¶á!",
            "message_type": "text",
            "timestamp": "2024-01-15T10:25:30+06:00"
        }
    ],
    "total_messages": 1
}
```

---

## üîå **‡ßß‡ß¨. WebSocket ‡¶ï‡¶æ‡¶®‡ßá‡¶ï‡¶∂‡¶®**

### **WebSocket URL ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü:**
```
ws://localhost:8000/ws/chat/{room_id}/?username={username}&color={color}&session_id={session_id}
```

### **JavaScript ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£:**

```javascript
// WebSocket ‡¶ï‡¶æ‡¶®‡ßá‡¶ï‡¶∂‡¶® ‡¶§‡ßà‡¶∞‡¶ø
const roomId = '123e4567-e89b-12d3-a456-426614174000';
const username = encodeURIComponent('‡¶∞‡¶æ‡¶ï‡¶ø‡¶¨');
const color = encodeURIComponent('#ff0000');
const sessionId = 'a1b2c3d4-e5f6-7890-1234-567890abcdef';

const wsUrl = `ws://localhost:8000/ws/chat/${roomId}/?username=${username}&color=${color}&session_id=${sessionId}`;
const socket = new WebSocket(wsUrl);

// ‡¶á‡¶≠‡ßá‡¶®‡ßç‡¶ü ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞
socket.onopen = function() {
    console.log('‚úÖ WebSocket ‡¶∏‡¶Ç‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá');
    
    // ‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶®
    socket.send(JSON.stringify({
        type: 'message',
        content: '‡¶∏‡¶¨‡¶æ‡¶á‡¶ï‡ßá ‡¶∏‡¶æ‡¶≤‡¶æ‡¶Æ!'
    }));
};

socket.onmessage = function(event) {
    const data = JSON.parse(event.data);
    
    switch(data.type) {
        case 'message':
            console.log(`üí¨ ${data.username}: ${data.message}`);
            break;
            
        case 'system':
            console.log(`‚ö° ${data.message}`);
            break;
            
        case 'typing':
            if(data.typing) {
                console.log(`‚úçÔ∏è ${data.username} ‡¶ü‡¶æ‡¶á‡¶™ ‡¶ï‡¶∞‡¶õ‡ßá...`);
            }
            break;
            
        case 'user_list':
            console.log('üë• ‡¶Ö‡¶®‡¶≤‡¶æ‡¶á‡¶® ‡¶á‡¶â‡¶ú‡¶æ‡¶∞:', data.users.length);
            break;
            
        case 'error':
            console.error(`‚ùå ${data.message}`);
            break;
    }
};

socket.onclose = function(event) {
    console.log('üîå WebSocket ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶¨‡¶ø‡¶ö‡ßç‡¶õ‡¶ø‡¶®‡ßç‡¶®');
    if(event.code === 4001) {
        console.log('‡¶∞‡ßÅ‡¶Æ ‡¶™‡ßÇ‡¶∞‡ßç‡¶£!');
    }
};

socket.onerror = function(error) {
    console.error('‚ùå WebSocket ‡¶è‡¶∞‡¶∞:', error);
};

// ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
function sendMessage(message) {
    if(socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'message',
            content: message
        }));
    }
}

// ‡¶ü‡¶æ‡¶á‡¶™‡¶ø‡¶Ç ‡¶á‡¶®‡ßç‡¶°‡¶ø‡¶ï‡ßá‡¶ü‡¶∞
function sendTyping(isTyping) {
    socket.send(JSON.stringify({
        type: 'typing',
        typing: isTyping
    }));
}

// ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
function updateUser(newUsername, newColor) {
    socket.send(JSON.stringify({
        type: 'user_update',
        username: newUsername,
        color: newColor
    }));
}
```

---

## üõ†Ô∏è **‡ßß‡ß≠. ‡¶ü‡ßç‡¶∞‡¶æ‡¶¨‡¶≤‡¶∂‡ßÅ‡¶ü‡¶ø‡¶Ç ‡¶ó‡¶æ‡¶á‡¶°**

### **‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡ßß: Channels ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßá ‡¶®‡¶æ**
```bash
# ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®: Daphne ‡¶á‡¶®‡¶∏‡ßç‡¶ü‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®
pip install daphne

# settings.py ‡¶è INSTALLED_APPS ‡¶è‡¶∞ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá 'daphne' ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®
INSTALLED_APPS = [
    'daphne',  # ‚úÖ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá
    # ...
]
```

### **‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡ß®: WebSocket ‡¶ï‡¶æ‡¶®‡ßá‡¶ï‡ßç‡¶ü ‡¶π‡¶ö‡ßç‡¶õ‡ßá ‡¶®‡¶æ**
```bash
# ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®: ASGI ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®
# ‡ßß. settings.py ‡¶è ASGI_APPLICATION ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®
ASGI_APPLICATION = 'bangla_chat.asgi.application'

# ‡ß®. Daphne ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶∞‡¶æ‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®
python -m daphne bangla_chat.asgi:application
```

### **‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡ß©: CORS ‡¶è‡¶∞‡¶∞**
```bash
# ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®: settings.py ‡¶è CORS ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®
INSTALLED_APPS = [
    # ...
    'corsheaders',  # ‚úÖ ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # ‚úÖ ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá
    # ...
]

CORS_ALLOW_ALL_ORIGINS = True  # ‚úÖ ‡¶°‡ßá‡¶≠‡ßá‡¶≤‡¶™‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø
```

### **‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡ß™: ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶ú ‡¶è‡¶∞‡¶∞**
```bash
# ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®: ‡¶Æ‡¶æ‡¶á‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶∞‡¶ø‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®
python manage.py migrate --fake chat_app zero
python manage.py makemigrations chat_app
python manage.py migrate chat_app
```

---

## üìä **‡ßß‡ßÆ. ‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶æ‡¶∞ ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡ßç‡¶ü**

### **test_chat.py** (‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü ‡¶∞‡ßÅ‡¶ü‡ßá ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®)

```python
"""
Test script for Bangla Public Chat API
"""

import requests
import json
import uuid
import websocket
import threading
import time

BASE_URL = "http://localhost:8000/api"
WS_URL = "ws://localhost:8000/ws/chat"

def test_system_status():
    """Test system status endpoint"""
    print("üîç Testing system status...")
    response = requests.get(f"{BASE_URL}/status/")
    print(f"Status: {response.status_code}")
    print(f"Response: {response.json()}")
    print("="*50)

def test_public_rooms():
    """Test public rooms endpoint"""
    print("üîç Testing public rooms...")
    response = requests.get(f"{BASE_URL}/public-rooms/")
    print(f"Status: {response.status_code}")
    data = response.json()
    print(f"Total rooms: {data['count']}")
    if data['rooms']:
        print(f"First room: {data['rooms'][0]['name']}")
    print("="*50)
    return data['rooms'][0]['id'] if data['rooms'] else None

def test_create_user():
    """Test user creation"""
    print("üîç Testing user creation...")
    data = {
        "username": "‡¶™‡¶∞‡ßÄ‡¶ï‡ßç‡¶∑‡¶ï",
        "color": "#00ff00"
    }
    response = requests.post(f"{BASE_URL}/create-user/", json=data)
    print(f"Status: {response.status_code}")
    user_data = response.json()
    print(f"User created: {user_data['username']}")
    print(f"Session ID: {user_data['session_id'][:20]}...")
    print("="*50)
    return user_data

def test_join_room(room_id, user_data):
    """Test joining a room"""
    print("üîç Testing room join...")
    data = {
        "room_id": room_id,
        "username": user_data['username'],
        "color": user_data['color']
    }
    response = requests.post(f"{BASE_URL}/join-room/", json=data)
    print(f"Status: {response.status_code}")
    join_data = response.json()
    print(f"Joined room: {join_data['room_name']}")
    print(f"WebSocket URL: {join_data['websocket_url'][:50]}...")
    print("="*50)
    return join_data

def test_websocket(join_data):
    """Test WebSocket connection"""
    print("üîå Testing WebSocket connection...")
    
    ws_url = join_data['websocket_url']
    
    def on_message(ws, message):
        data = json.loads(message)
        if data['type'] == 'system':
            print(f"‚ö° System: {data['message']}")
        elif data['type'] == 'message':
            print(f"üí¨ {data['username']}: {data['message']}")
    
    def on_error(ws, error):
        print(f"‚ùå WebSocket error: {error}")
    
    def on_close(ws, close_status_code, close_msg):
        print("üîå WebSocket disconnected")
    
    def on_open(ws):
        print("‚úÖ WebSocket connected")
        # Send a test message
        ws.send(json.dumps({
            "type": "message",
            "content": "‡¶π‡ßç‡¶Ø‡¶æ‡¶≤‡ßã! ‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ"
        }))
        time.sleep(2)
        ws.close()
    
    ws = websocket.WebSocketApp(
        ws_url,
        on_open=on_open,
        on_message=on_message,
        on_error=on_error,
        on_close=on_close
    )
    
    # Run in a separate thread
    wst = threading.Thread(target=ws.run_forever)
    wst.daemon = True
    wst.start()
    
    # Wait for connection
    time.sleep(3)

def main():
    """Run all tests"""
    print("üöÄ Starting Bangla Public Chat Tests")
    print("="*50)
    
    try:
        # Test 1: System status
        test_system_status()
        
        # Test 2: Get public rooms
        room_id = test_public_rooms()
        
        if room_id:
            # Test 3: Create user
            user_data = test_create_user()
            
            # Test 4: Join room
            join_data = test_join_room(room_id, user_data)
            
            # Test 5: WebSocket
            test_websocket(join_data)
        
        print("‚úÖ All tests completed successfully!")
        
    except Exception as e:
        print(f"‚ùå Test failed: {e}")

if __name__ == "__main__":
    main()
```

**‡¶∞‡¶æ‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø:**
```bash
# ‡¶™‡ßç‡¶∞‡¶•‡¶Æ‡ßá requirements.txt ‡¶è ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®:
# websocket-client==1.6.1

pip install websocket-client

# ‡¶§‡¶æ‡¶∞‡¶™‡¶∞ ‡¶ü‡ßá‡¶∏‡ßç‡¶ü ‡¶∞‡¶æ‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®
python test_chat.py
```

---

## üìã **‡ßß‡ßØ. Deployment ‡¶ó‡¶æ‡¶á‡¶°**

### **Production ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏ (settings.py):**

```python
# Production settings
DEBUG = False
ALLOWED_HOSTS = ['yourdomain.com', 'www.yourdomain.com']

# Security
SECURE_SSL_REDISRECT = True
SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True

# Redis for Channels
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [('127.0.0.1', 6379)],
        },
    },
}

# CORS for production
CORS_ALLOW_ALL_ORIGINS = False
CORS_ALLOWED_ORIGINS = [
    "https://yourdomain.com",
    "https://www.yourdomain.com",
]

# Database (PostgreSQL recommended)
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'bangla_chat_db',
        'USER': 'chat_user',
        'PASSWORD': 'strong_password',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```

### **Gunicorn + Daphne ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶®:**

**gunicorn_config.py:**
```python
bind = "0.0.0.0:8000"
workers = 3
worker_class = "uvicorn.workers.UvicornWorker"
```

**‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶∞‡¶æ‡¶®:**
```bash
# Daphne (WebSocket)
daphne -b 0.0.0.0 -p 8001 bangla_chat.asgi:application

# Gunicorn (HTTP)
gunicorn -c gunicorn_config.py bangla_chat.wsgi:application
```

---

## üìö **‡ß®‡ß¶. ‡¶Ö‡¶§‡¶ø‡¶∞‡¶ø‡¶ï‡ßç‡¶§ ‡¶∞‡¶ø‡¶∏‡ßã‡¶∞‡ßç‡¶∏**

### **‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ú ‡¶≠‡¶æ‡¶∞‡ßç‡¶∂‡¶®:**
```txt
Django==4.2.7
channels==4.0.0
channels-redis==4.1.0
daphne==4.0.0
djangorestframework==3.14.0
django-cors-headers==4.2.0
redis==5.0.1
```

### **‡¶´‡¶æ‡¶Ø‡¶º‡¶æ‡¶∞‡¶ì‡¶Ø‡¶º‡¶æ‡¶≤ ‡¶™‡ßã‡¶∞‡ßç‡¶ü‡¶∏:**
```bash
# Open necessary ports
sudo ufw allow 8000/tcp  # HTTP
sudo ufw allow 8001/tcp  # WebSocket
sudo ufw allow 6379/tcp  # Redis (if using)
```

### **‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶ø‡¶∏ ‡¶´‡¶æ‡¶á‡¶≤ (systemd):**

**/etc/systemd/system/bangla-chat.service:**
```ini
[Unit]
Description=Bangla Public Chat Service
After=network.target

[Service]
User=www-data
Group=www-data
WorkingDirectory=/path/to/bangla-public-chat
Environment="PATH=/path/to/bangla-public-chat/venv/bin"
ExecStart=/path/to/bangla-public-chat/venv/bin/daphne -b 0.0.0.0 -p 8001 bangla_chat.asgi:application
Restart=always

[Install]
WantedBy=multi-user.target
```

**Enable service:**
```bash
sudo systemctl daemon-reload
sudo systemctl start bangla-chat
sudo systemctl enable bangla-chat
```

---

## üéØ **‡¶∏‡¶æ‡¶∞‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡ßá‡¶™**

‡¶è‡¶á ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®‡ßá ‡¶Ü‡¶™‡¶®‡¶ø ‡¶™‡ßá‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶®:

‚úÖ ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ Django ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞  
‚úÖ WebSocket-‡¶è‡¶∞ ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶á‡¶Æ‡¶™‡ßç‡¶≤‡¶ø‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®  
‚úÖ ‡¶≤‡¶ó‡¶á‡¶®-‡¶õ‡¶æ‡¶°‡¶º‡¶æ ‡¶™‡¶æ‡¶¨‡¶≤‡¶ø‡¶ï ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ  
‚úÖ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶≠‡¶æ‡¶∑‡¶æ ‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü  
‚úÖ REST API ‡¶°‡¶ï‡ßÅ‡¶Æ‡ßá‡¶®‡ßç‡¶ü‡ßá‡¶∂‡¶®  
‚úÖ ‡¶ü‡ßç‡¶∞‡¶æ‡¶¨‡¶≤‡¶∂‡ßÅ‡¶ü‡¶ø‡¶Ç ‡¶ó‡¶æ‡¶á‡¶°  
‚úÖ Deployment ‡¶ó‡¶æ‡¶á‡¶°  

**‡¶∞‡ßá‡¶°‡¶ø-‡¶ü‡ßÅ-‡¶á‡¶â‡¶ú ‡¶´‡¶æ‡¶á‡¶≤‡¶∏:**
1. `requirements.txt` - ‡¶∏‡¶¨ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡ßÄ‡¶Ø‡¶º ‡¶™‡ßç‡¶Ø‡¶æ‡¶ï‡ßá‡¶ú
2. `settings.py` - ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶®
3. `models.py` - ‡¶∏‡¶¨ ‡¶Æ‡¶°‡ßá‡¶≤
4. `consumers.py` - WebSocket ‡¶≤‡¶ú‡¶ø‡¶ï
5. `views.py` - ‡¶∏‡¶¨ API ‡¶è‡¶®‡ßç‡¶°‡¶™‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü
6. `test_chat.py` - ‡¶ü‡ßá‡¶∏‡ßç‡¶ü‡¶ø‡¶Ç ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡ßç‡¶ü

**‡¶ï‡ßÅ‡¶á‡¶ï ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü:**
```bash
# ‡ßß. ‡¶´‡¶æ‡¶á‡¶≤‡¶∏ ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®
# ‡ß®. ‡¶≠‡¶æ‡¶∞‡ßç‡¶ö‡ßÅ‡¶Ø‡¶º‡¶æ‡¶≤ ‡¶è‡¶®‡¶≠‡¶æ‡¶Ø‡¶º‡¶∞‡¶®‡¶Æ‡ßá‡¶®‡ßç‡¶ü ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®
# ‡ß©. requirements.txt ‡¶á‡¶®‡ßç‡¶∏‡¶ü‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®
# ‡ß™. ‡¶Æ‡¶æ‡¶á‡¶ó‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶∞‡¶æ‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®
# ‡ß´. ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®
```

**‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü:**
‡¶Ø‡¶¶‡¶ø ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º, ‡¶è‡¶á ‡¶ö‡ßá‡¶ï‡¶≤‡¶ø‡¶∏‡ßç‡¶ü ‡¶´‡¶≤‡ßã ‡¶ï‡¶∞‡ßÅ‡¶®:
1. `CHANNEL_LAYERS` settings.py-‡¶è ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ
2. `ASGI_APPLICATION` ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ
3. Daphne installed and in INSTALLED_APPS
4. All migrations applied

**‡¶π‡ßç‡¶Ø‡¶æ‡¶™‡¶ø ‡¶ï‡ßã‡¶°‡¶ø‡¶Ç! üöÄ**